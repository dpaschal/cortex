syntax = "proto3";

package cortex;

option java_multiple_files = true;
option java_package = "com.dpaschal.cortex";

// ============================================================================
// Core Service Definitions
// ============================================================================

// ClusterService handles cluster coordination and task management
service ClusterService {
  // Node registration and membership
  rpc RegisterNode(RegisterNodeRequest) returns (RegisterNodeResponse);
  rpc DeregisterNode(DeregisterNodeRequest) returns (DeregisterNodeResponse);
  rpc Heartbeat(HeartbeatRequest) returns (HeartbeatResponse);
  rpc GetClusterState(GetClusterStateRequest) returns (ClusterState);

  // Task management
  rpc SubmitTask(SubmitTaskRequest) returns (SubmitTaskResponse);
  rpc GetTaskStatus(GetTaskStatusRequest) returns (TaskStatus);
  rpc CancelTask(CancelTaskRequest) returns (CancelTaskResponse);
  rpc StreamTaskOutput(StreamTaskOutputRequest) returns (stream TaskOutput);

  // Claude-to-Claude communication
  rpc RegisterSession(RegisterSessionRequest) returns (RegisterSessionResponse);
  rpc QuerySessions(QuerySessionsRequest) returns (QuerySessionsResponse);
  rpc RelayToSession(RelayRequest) returns (RelayResponse);
  rpc PublishContext(PublishContextRequest) returns (PublishContextResponse);
  rpc QueryContext(QueryContextRequest) returns (QueryContextResponse);

  // Shared memory write forwarding (follower -> leader)
  rpc ForwardMemoryWrite(MemoryWriteRequest) returns (MemoryWriteResponse);

  // Shared memory snapshot transfer (new node <- leader)
  rpc RequestMemorySnapshot(MemorySnapshotRequest) returns (stream MemorySnapshotChunk);
}

// RaftService handles consensus protocol
service RaftService {
  rpc RequestVote(RequestVoteRequest) returns (RequestVoteResponse);
  rpc AppendEntries(AppendEntriesRequest) returns (AppendEntriesResponse);
  rpc InstallSnapshot(InstallSnapshotRequest) returns (InstallSnapshotResponse);
}

// AgentService runs on each node for task execution
service AgentService {
  rpc ExecuteTask(ExecuteTaskRequest) returns (stream ExecuteTaskResponse);
  rpc GetResources(GetResourcesRequest) returns (NodeResources);
  rpc HealthCheck(HealthCheckRequest) returns (HealthCheckResponse);
  rpc CancelExecution(CancelExecutionRequest) returns (CancelExecutionResponse);
}

// ============================================================================
// Node and Membership Messages
// ============================================================================

message NodeInfo {
  string node_id = 1;
  string hostname = 2;
  string tailscale_ip = 3;
  int32 grpc_port = 4;
  NodeRole role = 5;
  NodeStatus status = 6;
  NodeResources resources = 7;
  repeated string tags = 8;
  int64 joined_at = 9;
  int64 last_seen = 10;
}

enum NodeRole {
  NODE_ROLE_UNKNOWN = 0;
  NODE_ROLE_LEADER = 1;
  NODE_ROLE_FOLLOWER = 2;
  NODE_ROLE_CANDIDATE = 3;
  NODE_ROLE_WORKER = 4;  // Non-voting worker node
}

enum NodeStatus {
  NODE_STATUS_UNKNOWN = 0;
  NODE_STATUS_PENDING_APPROVAL = 1;
  NODE_STATUS_ACTIVE = 2;
  NODE_STATUS_DRAINING = 3;
  NODE_STATUS_OFFLINE = 4;
}

message NodeResources {
  int32 cpu_cores = 1;
  int64 memory_bytes = 2;
  int64 memory_available_bytes = 3;
  repeated GpuInfo gpus = 4;
  int64 disk_bytes = 5;
  int64 disk_available_bytes = 6;
  double cpu_usage_percent = 7;
  bool gaming_detected = 8;
}

message GpuInfo {
  string name = 1;
  int64 memory_bytes = 2;
  int64 memory_available_bytes = 3;
  double utilization_percent = 4;
  bool in_use_for_gaming = 5;
}

message RegisterNodeRequest {
  NodeInfo node = 1;
  string auth_token = 2;
}

message RegisterNodeResponse {
  bool approved = 1;
  bool pending_approval = 2;
  string cluster_id = 3;
  string leader_address = 4;
  repeated NodeInfo peers = 5;
}

message DeregisterNodeRequest {
  string node_id = 1;
  bool graceful = 2;
}

message DeregisterNodeResponse {
  bool success = 1;
}

message HeartbeatRequest {
  string node_id = 1;
  NodeResources resources = 2;
  repeated string active_tasks = 3;
}

message HeartbeatResponse {
  bool acknowledged = 1;
  string leader_address = 2;
  repeated PendingTask pending_tasks = 3;
  string leader_id = 4;
}

message PendingTask {
  string task_id = 1;
  TaskSpec spec = 2;
}

message GetClusterStateRequest {}

message ClusterState {
  string cluster_id = 1;
  string leader_id = 2;
  int64 term = 3;
  repeated NodeInfo nodes = 4;
  ClusterResources total_resources = 5;
  ClusterResources available_resources = 6;
  int32 active_tasks = 7;
  int32 queued_tasks = 8;
}

message ClusterResources {
  int32 cpu_cores = 1;
  int64 memory_bytes = 2;
  int32 gpu_count = 3;
  int64 gpu_memory_bytes = 4;
}

// ============================================================================
// Task Messages
// ============================================================================

message TaskSpec {
  string task_id = 1;
  TaskType type = 2;
  string submitter_node = 3;
  string submitter_session = 4;

  oneof payload {
    ShellTask shell = 10;
    ContainerTask container = 11;
    SubagentTask subagent = 12;
    K8sJobTask k8s_job = 13;
    ClaudeRelayTask claude_relay = 14;
  }

  ResourceRequirements requirements = 20;
  TaskConstraints constraints = 21;
  int32 priority = 22;
  int64 timeout_ms = 23;
  map<string, string> environment = 24;
  repeated string target_nodes = 25;  // Empty = scheduler decides
}

enum TaskType {
  TASK_TYPE_UNKNOWN = 0;
  TASK_TYPE_SHELL = 1;
  TASK_TYPE_CONTAINER = 2;
  TASK_TYPE_SUBAGENT = 3;
  TASK_TYPE_K8S_JOB = 4;
  TASK_TYPE_CLAUDE_RELAY = 5;
}

message ShellTask {
  string command = 1;
  string working_directory = 2;
  bool sandboxed = 3;
}

message ContainerTask {
  string image = 1;
  repeated string command = 2;
  repeated string args = 3;
  map<string, string> labels = 4;
  repeated VolumeMount mounts = 5;
}

message VolumeMount {
  string host_path = 1;
  string container_path = 2;
  bool read_only = 3;
}

message SubagentTask {
  string prompt = 1;
  string model = 2;
  repeated string tools = 3;
  string context_summary = 4;
  int32 max_turns = 5;
}

message K8sJobTask {
  string cluster_context = 1;
  string namespace = 2;
  string image = 3;
  repeated string command = 4;
  map<string, string> labels = 5;
  ResourceRequirements resources = 6;
}

message ClaudeRelayTask {
  string target_session_id = 1;
  string prompt = 2;
  string full_context = 3;  // Full conversation context, not just prompt
  bool await_response = 4;
}

message ResourceRequirements {
  int32 cpu_cores = 1;
  int64 memory_bytes = 2;
  bool requires_gpu = 3;
  int64 gpu_memory_bytes = 4;
}

message TaskConstraints {
  repeated string allowed_nodes = 1;
  repeated string excluded_nodes = 2;
  bool prefer_local = 3;
  bool avoid_gaming_nodes = 4;
}

message SubmitTaskRequest {
  TaskSpec spec = 1;
}

message SubmitTaskResponse {
  string task_id = 1;
  bool accepted = 2;
  string assigned_node = 3;
  string rejection_reason = 4;
}

message GetTaskStatusRequest {
  string task_id = 1;
}

message TaskStatus {
  string task_id = 1;
  TaskState state = 2;
  string assigned_node = 3;
  int64 started_at = 4;
  int64 completed_at = 5;
  int32 exit_code = 6;
  string error = 7;
  TaskResult result = 8;
}

enum TaskState {
  TASK_STATE_UNKNOWN = 0;
  TASK_STATE_QUEUED = 1;
  TASK_STATE_ASSIGNED = 2;
  TASK_STATE_RUNNING = 3;
  TASK_STATE_COMPLETED = 4;
  TASK_STATE_FAILED = 5;
  TASK_STATE_CANCELLED = 6;
}

message TaskResult {
  bytes stdout = 1;
  bytes stderr = 2;
  int32 exit_code = 3;
  map<string, bytes> artifacts = 4;
}

message CancelTaskRequest {
  string task_id = 1;
}

message CancelTaskResponse {
  bool cancelled = 1;
}

message StreamTaskOutputRequest {
  string task_id = 1;
}

message TaskOutput {
  OutputType type = 1;
  bytes data = 2;
  int64 timestamp = 3;
}

enum OutputType {
  OUTPUT_TYPE_UNKNOWN = 0;
  OUTPUT_TYPE_STDOUT = 1;
  OUTPUT_TYPE_STDERR = 2;
  OUTPUT_TYPE_STATUS = 3;
}

// ============================================================================
// Workflow Messages
// ============================================================================

message RetryPolicy {
  int32 max_retries = 1;
  int64 backoff_ms = 2;
  double backoff_multiplier = 3;
  bool retryable = 4;
}

message SubmitWorkflowRequest {
  string name = 1;
  map<string, WorkflowTaskDef> tasks = 2;
}

message WorkflowTaskDef {
  TaskSpec spec = 1;
  repeated string depends_on = 2;
  string condition = 3;
}

message WorkflowStatus {
  string workflow_id = 1;
  string name = 2;
  string state = 3;
  map<string, TaskStatus> task_statuses = 4;
  string context_json = 5;
}

// ============================================================================
// Raft Consensus Messages
// ============================================================================

message RequestVoteRequest {
  int64 term = 1;
  string candidate_id = 2;
  int64 last_log_index = 3;
  int64 last_log_term = 4;
}

message RequestVoteResponse {
  int64 term = 1;
  bool vote_granted = 2;
}

message AppendEntriesRequest {
  int64 term = 1;
  string leader_id = 2;
  int64 prev_log_index = 3;
  int64 prev_log_term = 4;
  repeated LogEntry entries = 5;
  int64 leader_commit = 6;
}

message LogEntry {
  int64 term = 1;
  int64 index = 2;
  LogEntryType type = 3;
  bytes data = 4;
}

enum LogEntryType {
  LOG_ENTRY_TYPE_UNKNOWN = 0;
  LOG_ENTRY_TYPE_NOOP = 1;
  LOG_ENTRY_TYPE_CONFIG_CHANGE = 2;
  LOG_ENTRY_TYPE_TASK_SUBMIT = 3;
  LOG_ENTRY_TYPE_TASK_COMPLETE = 4;
  LOG_ENTRY_TYPE_NODE_JOIN = 5;
  LOG_ENTRY_TYPE_NODE_LEAVE = 6;
  LOG_ENTRY_TYPE_CONTEXT_UPDATE = 7;
  LOG_ENTRY_TYPE_MEMORY_WRITE = 8;
  LOG_ENTRY_TYPE_TASK_ASSIGN = 10;
  LOG_ENTRY_TYPE_TASK_STARTED = 11;
  LOG_ENTRY_TYPE_TASK_FAILED = 12;
  LOG_ENTRY_TYPE_TASK_CANCEL = 13;
  LOG_ENTRY_TYPE_TASK_RETRY = 14;
  LOG_ENTRY_TYPE_TASK_DEAD_LETTER = 15;
  LOG_ENTRY_TYPE_WORKFLOW_SUBMIT = 16;
  LOG_ENTRY_TYPE_WORKFLOW_ADVANCE = 17;
}

message AppendEntriesResponse {
  int64 term = 1;
  bool success = 2;
  int64 match_index = 3;
}

message InstallSnapshotRequest {
  int64 term = 1;
  string leader_id = 2;
  int64 last_included_index = 3;
  int64 last_included_term = 4;
  int64 offset = 5;
  bytes data = 6;
  bool done = 7;
}

message InstallSnapshotResponse {
  int64 term = 1;
}

// ============================================================================
// Agent Execution Messages
// ============================================================================

message ExecuteTaskRequest {
  TaskSpec spec = 1;
}

message ExecuteTaskResponse {
  oneof response {
    TaskOutput output = 1;
    TaskStatus status = 2;
  }
}

message GetResourcesRequest {}

message HealthCheckRequest {}

message HealthCheckResponse {
  bool healthy = 1;
  string message = 2;
  NodeResources resources = 3;
}

message CancelExecutionRequest {
  string task_id = 1;
}

message CancelExecutionResponse {
  bool cancelled = 1;
}

// ============================================================================
// Claude Session Messages
// ============================================================================

message ClaudeSession {
  string session_id = 1;
  string node_id = 2;
  string project = 3;
  string working_directory = 4;
  SessionMode mode = 5;
  int64 started_at = 6;
  int64 last_active = 7;
  string context_summary = 8;
}

enum SessionMode {
  SESSION_MODE_NORMAL = 0;
  SESSION_MODE_INVISIBLE = 1;  // Can read cluster, hidden from others
  SESSION_MODE_ISOLATED = 2;   // No cluster connection
}

message RegisterSessionRequest {
  ClaudeSession session = 1;
}

message RegisterSessionResponse {
  bool registered = 1;
  repeated ClaudeSession other_sessions = 2;
}

message QuerySessionsRequest {
  string project_filter = 1;
  string node_filter = 2;
}

message QuerySessionsResponse {
  repeated ClaudeSession sessions = 1;
}

message RelayRequest {
  string target_session_id = 1;
  string from_session_id = 2;
  string message = 3;
  string full_context = 4;
}

message RelayResponse {
  bool delivered = 1;
  string response = 2;
}

// ============================================================================
// Shared Context Messages
// ============================================================================

message ContextEntry {
  string entry_id = 1;
  string session_id = 2;
  string node_id = 3;
  string project = 4;
  ContextType type = 5;
  string key = 6;
  string value = 7;
  int64 timestamp = 8;
  int64 vector_clock = 9;  // For CRDT conflict resolution
  ContextVisibility visibility = 10;
}

enum ContextType {
  CONTEXT_TYPE_UNKNOWN = 0;
  CONTEXT_TYPE_PROJECT_SUMMARY = 1;
  CONTEXT_TYPE_DECISION = 2;
  CONTEXT_TYPE_ERROR_SOLUTION = 3;
  CONTEXT_TYPE_FILE_CHANGE = 4;
  CONTEXT_TYPE_LEARNING = 5;
}

enum ContextVisibility {
  CONTEXT_VISIBILITY_CLUSTER = 0;  // Visible to all sessions
  CONTEXT_VISIBILITY_PROJECT = 1;  // Only same project
  CONTEXT_VISIBILITY_SESSION = 2;  // Only originating session
}

message PublishContextRequest {
  ContextEntry entry = 1;
}

message PublishContextResponse {
  bool published = 1;
}

message QueryContextRequest {
  string project_filter = 1;
  repeated ContextType type_filter = 2;
  int64 since_timestamp = 3;
  int32 limit = 4;
}

message QueryContextResponse {
  repeated ContextEntry entries = 1;
}

// ============================================================================
// Shared Memory Messages
// ============================================================================

message MemoryWriteRequest {
  string sql = 1;
  string params = 2;       // JSON-encoded array
  string checksum = 3;     // SHA-256 of sql + params
  string classification = 4;
  string table = 5;
}

message MemoryWriteResponse {
  bool success = 1;
  string error = 2;
}

message MemorySnapshotRequest {
  string requesting_node_id = 1;
}

message MemorySnapshotChunk {
  bytes data = 1;
  int64 offset = 2;
  int64 total_size = 3;
  bool done = 4;
  string checksum = 5;  // SHA-256 of complete file, sent with done=true
}
